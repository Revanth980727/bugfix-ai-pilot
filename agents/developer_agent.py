
import os
import time
import json
from typing import Dict, Any, List, Optional
import openai
from .utils.logger import Logger
from .utils.openai_client import OpenAIClient

class DeveloperAgent:
    """
    Agent responsible for generating code fixes based on PlannerAgent's task plan.
    Uses GPT-4 to generate code patches and handles multiple retry attempts.
    """
    
    def __init__(self, max_retries: int = 4):
        """
        Initialize the developer agent
        
        Args:
            max_retries: Maximum number of retry attempts for generating a successful patch
        """
        self.logger = Logger("developer_agent")
        self.max_retries = max_retries
        
        # Get repo path from environment
        self.repo_path = os.environ.get("REPO_PATH", "/mnt/codebase")
        
        # Initialize OpenAI client
        self.openai_client = OpenAIClient()
    
    def run(self, task_plan: Dict[str, Any]) -> Dict[str, Any]:
        """
        Generate code fixes based on the task plan
        
        Args:
            task_plan: The task plan generated by PlannerAgent including context with previous attempts
                       and QA failure information
            
        Returns:
            Dictionary with patch information:
            {
                "patch_content": "unified diff content",
                "patched_files": ["list", "of", "patched", "files"],
                "commit_message": "Description of changes",
                "attempt": 1,
                "success": true
            }
        """
        # Ensure we have a valid task_plan
        if not task_plan:
            self.logger.error("Invalid task plan: None or empty")
            return {
                "error": "Invalid task plan provided",
                "patch_content": "",
                "patched_files": [],
                "commit_message": "",
                "attempt": 1,
                "ticket_id": "unknown",
                "success": False
            }
            
        ticket_id = task_plan.get("ticket_id", "unknown")
        self.logger.start_task(f"Generating code fix for ticket {ticket_id}")
        
        # Extract context if available
        context = task_plan.get("context", {}) or {}  # Ensure context is a dict, not None
        attempt = context.get("attempt", 1)
        previous_attempts = context.get("previousAttempts", []) or []  # Ensure previous_attempts is a list, not None
            
        self.logger.info(f"Starting fix attempt {attempt}/{self.max_retries}")
        
        try:
            # Generate the fix using OpenAI
            patch_data = self.generate_fix(task_plan, attempt, previous_attempts)
            
            # Add metadata
            patch_data["attempt"] = attempt
            patch_data["ticket_id"] = ticket_id
            
            # Save patch to file
            patch_file_path = f"logs/patch_{ticket_id}_attempt_{attempt}.patch"
            os.makedirs("logs", exist_ok=True)
            with open(patch_file_path, "w") as f:
                f.write(patch_data.get("patch_content", "") or "")  # Handle None case
                
            self.logger.info(f"Patch saved to {patch_file_path}")
            
            # Set success status (actual verification happens in QA agent)
            patch_data["success"] = True
            
            self.logger.end_task(f"Code generation for ticket {ticket_id}", success=True)
            return patch_data
            
        except Exception as e:
            self.logger.error(f"Code generation failed: {str(e)}")
            self.logger.end_task(f"Code generation for ticket {ticket_id}", success=False)
            
            # Return error response
            return {
                "error": str(e),
                "patch_content": "",
                "patched_files": [],
                "commit_message": "",
                "attempt": attempt,
                "ticket_id": ticket_id,
                "success": False
            }
            
    def generate_fix(self, task_plan: Dict[str, Any], attempt: int = 1, 
                     previous_attempts: List[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Generate a code fix based on the task plan using GPT-4
        
        Args:
            task_plan: The task plan from PlannerAgent
            attempt: Current attempt number
            previous_attempts: List of previous attempts and their results
            
        Returns:
            Dictionary with patch information
        """
        if previous_attempts is None:
            previous_attempts = []
            
        # Read file contents for the files identified in the task plan
        files_list = task_plan.get("files", []) or []  # Ensure files is a list, not None
        file_contents = self._read_identified_files(files_list)
        
        # Create prompt for GPT-4
        prompt = self._create_developer_prompt(task_plan, file_contents, previous_attempts)
        
        # Get code fix from GPT-4
        self.logger.info(f"Sending prompt to GPT-4 for code generation (attempt {attempt})")
        response = self.openai_client.generate_completion(prompt)
        
        # Log the actual response for debugging
        self.logger.info(f"Received response from OpenAI API (length: {len(response) if response else 0})")
        self.logger.debug(f"Full OpenAI response: {response[:500]}...")  # Log first 500 chars to avoid excessive logging
        
        # Save the full response to a file for analysis
        os.makedirs("logs", exist_ok=True)
        response_file_path = f"logs/openai_response_{task_plan.get('ticket_id', 'unknown')}_attempt_{attempt}.txt"
        with open(response_file_path, "w") as f:
            f.write(response or "Empty response")
        self.logger.info(f"Saved full OpenAI response to {response_file_path}")
        
        if not response:
            raise Exception(f"Failed to generate code fix. OpenAI API call failed on attempt {attempt}.")
        
        # Parse the response to extract the patch content
        return self._extract_patch(response, task_plan)
            
    # ... keep existing code (file content retrieval logic)
        
    def _create_developer_prompt(self, task_plan: Dict[str, Any], 
                              file_contents: Dict[str, str],
                              previous_attempts: List[Dict[str, Any]]) -> str:
        """
        Create a prompt for GPT-4 to generate a code fix
        
        Args:
            task_plan: The task plan from PlannerAgent
            file_contents: Dictionary mapping file paths to their contents
            previous_attempts: List of previous fix attempts and their results
            
        Returns:
            Prompt for GPT-4
        """
        # Basic prompt with task plan info
        prompt = f"""
        You are a senior software developer implementing a fix for a bug based on the following analysis:
        
        Bug Title: {task_plan.get('title', 'No title provided')}
        
        Bug Description: {task_plan.get('description', 'No description provided')}
        
        Root Cause: {task_plan.get('root_cause', 'Unknown')}
        
        Approach: {task_plan.get('approach', 'Not specified')}
        
        Implementation Details: {task_plan.get('implementation_details', 'Not specified')}
        
        """
        
        # Add file contents section
        prompt += "\nHere are the contents of the relevant files:\n\n"
        
        for file_path, content in file_contents.items():
            prompt += f"--- {file_path} ---\n"
            prompt += content
            prompt += "\n\n"
            
        # Add information from previous attempts if available
        if previous_attempts:
            prompt += "\nPrevious fix attempts:\n\n"
            
            for i, attempt in enumerate(previous_attempts):
                if not isinstance(attempt, dict):
                    continue
                    
                prompt += f"Attempt {i+1}:\n"
                
                # Add patch content if available
                if "patch_content" in attempt:
                    prompt += f"Patch:\n{attempt['patch_content']}\n"
                
                # Add QA results and failure summary
                qa_results = attempt.get("qa_results", {}) or {}  # Ensure qa_results is a dict, not None
                if qa_results:
                    passed = qa_results.get("passed", False)
                    prompt += f"Test Result: {'PASSED' if passed else 'FAILED'}\n"
                    
                    if not passed:
                        # Add more detailed QA failure information
                        if "failure_summary" in qa_results:
                            prompt += f"Test Failure Summary:\n{qa_results['failure_summary']}\n"
                        elif "error_message" in qa_results:
                            prompt += f"Error: {qa_results['error_message']}\n"
                
                prompt += "\n"
                
            # Add specific guidance for retry attempts
            if len(previous_attempts) > 0:
                last_attempt = previous_attempts[-1]
                if isinstance(last_attempt, dict):
                    qa_results = last_attempt.get("qa_results", {}) or {}  # Ensure qa_results is a dict, not None
                    if qa_results and not qa_results.get("passed", False):
                        prompt += """
                        Note: The previous fix attempt failed. Please analyze the test failure information above
                        and adjust your new patch to address these specific issues. Focus on fixing the exact
                        problems indicated by the test failures.
                        """
                
        # Instructions for generating the fix
        prompt += """
        Please implement a fix for the bug based on the analysis and file contents above.
        
        Provide your solution in the form of a unified diff/patch format. Include the entire file content
        for each modified file, not just the changes. Be specific and detailed in your solution.
        
        DO NOT provide a generic response. Your solution MUST be in this specific patch format:
        
        ```patch
        --- a/path/to/file1.py
        +++ b/path/to/file1.py
        @@ -line_start,line_count +line_start,line_count @@
         unchanged line
        -removed line
        +added line
         unchanged line
        
        --- a/path/to/file2.py
        +++ b/path/to/file2.py
        @@ -line_start,line_count +line_start,line_count @@
         unchanged line
        -removed line
        +added line
         unchanged line
        ```
        
        Please also include a brief commit message summarizing the changes at the start of your response.
        """
        
        return prompt
            
    def _extract_patch(self, response: str, task_plan: Dict[str, Any]) -> Dict[str, Any]:
        """
        Extract the patch content from GPT-4's response
        
        Args:
            response: GPT-4's response text
            task_plan: Original task plan
            
        Returns:
            Dictionary with patch_content, patched_files, and commit_message
        """
        if not response:
            self.logger.error("Empty response received from OpenAI")
            return {
                "patch_content": "",
                "patched_files": [],
                "commit_message": "No changes made"
            }
            
        # Extract commit message (first line or paragraph)
        lines = response.strip().split('\n')
        commit_message = lines[0].strip() if lines else "Fix implemented"
        
        # Find the patch content
        patch_start = response.find("```patch")
        if patch_start == -1:
            patch_start = response.find("```diff")
        
        if patch_start == -1:
            # No patch block found, look for --- patterns
            patch_lines = []
            in_patch = False
            
            for line in lines:
                if line.startswith("---") and "/path/to/" not in line:
                    in_patch = True
                
                if in_patch:
                    patch_lines.append(line)
                    
            patch_content = "\n".join(patch_lines)
            
            # If we still don't have a patch, log an error
            if not patch_content:
                self.logger.error("Could not extract patch from response. Response appears to be generic or invalid.")
                self.logger.debug(f"Response excerpt: {response[:200]}...")
                
        else:
            # Extract content between code blocks
            patch_start += 8  # Skip ```patch or ```diff
            patch_end = response.find("```", patch_start)
            
            if patch_end == -1:
                patch_content = response[patch_start:].strip()
            else:
                patch_content = response[patch_start:patch_end].strip()
                
        # Extract patched file paths
        patched_files = []
        for line in patch_content.split("\n"):
            if line.startswith("+++ b/"):
                file_path = line[6:].strip()
                patched_files.append(file_path)
                
        # If no patched files could be identified, try to get them from the task plan
        if not patched_files:
            files_list = task_plan.get("files", []) or []  # Ensure files is a list, not None
            for file_info in files_list:
                if isinstance(file_info, dict):
                    file_path = file_info.get("path", "")
                    if file_path:
                        patched_files.append(file_path)
        
        # Log the extraction results            
        self.logger.info(f"Extracted patch for {len(patched_files)} files: {', '.join(patched_files) if patched_files else 'No files identified'}")
        if not patch_content or len(patch_content) < 10:
            self.logger.warning("Patch content appears invalid or too short")
        
        # Build the result
        return {
            "patch_content": patch_content,
            "patched_files": patched_files,
            "commit_message": commit_message
        }
        
    # ... keep existing code (remaining methods)
