
import os
import time
import json
from typing import Dict, Any, List, Optional
import openai
from .utils.logger import Logger
from .utils.openai_client import OpenAIClient

class DeveloperAgent:
    """
    Agent responsible for generating code fixes based on PlannerAgent's task plan.
    Uses GPT-4 to generate code patches and handles multiple retry attempts.
    """
    
    def __init__(self, max_retries: int = 4):
        """
        Initialize the developer agent
        
        Args:
            max_retries: Maximum number of retry attempts for generating a successful patch
        """
        self.logger = Logger("developer_agent")
        self.max_retries = max_retries
        
        # Get repo path from environment
        self.repo_path = os.environ.get("REPO_PATH", "/mnt/codebase")
        
        # Initialize OpenAI client
        self.openai_client = OpenAIClient()
    
    def run(self, task_plan: Dict[str, Any], context: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Generate code fixes based on the task plan
        
        Args:
            task_plan: The task plan generated by PlannerAgent
            context: Optional context with previous attempts and results
            
        Returns:
            Dictionary with patch information:
            {
                "patch_content": "unified diff content",
                "patched_files": ["list", "of", "patched", "files"],
                "commit_message": "Description of changes",
                "attempt": 1,
                "success": true
            }
        """
        ticket_id = task_plan.get("ticket_id", "unknown")
        self.logger.start_task(f"Generating code fix for ticket {ticket_id}")
        
        attempt = 1
        if context and "attempt" in context:
            attempt = context["attempt"]
            
        previous_attempts = []
        if context and "previous_attempts" in context:
            previous_attempts = context["previous_attempts"]
            
        self.logger.info(f"Starting fix attempt {attempt}/{self.max_retries}")
        
        try:
            # Generate the fix using OpenAI
            patch_data = self.generate_fix(task_plan, attempt, previous_attempts)
            
            # Add metadata
            patch_data["attempt"] = attempt
            patch_data["ticket_id"] = ticket_id
            
            # Save patch to file
            patch_file_path = f"logs/patch_{ticket_id}_attempt_{attempt}.patch"
            os.makedirs("logs", exist_ok=True)
            with open(patch_file_path, "w") as f:
                f.write(patch_data["patch_content"])
                
            self.logger.info(f"Patch saved to {patch_file_path}")
            
            # Set success status (actual verification happens in QA agent)
            patch_data["success"] = True
            
            self.logger.end_task(f"Code generation for ticket {ticket_id}", success=True)
            return patch_data
            
        except Exception as e:
            self.logger.error(f"Code generation failed: {str(e)}")
            self.logger.end_task(f"Code generation for ticket {ticket_id}", success=False)
            
            # Return error response
            return {
                "error": str(e),
                "patch_content": "",
                "patched_files": [],
                "commit_message": "",
                "attempt": attempt,
                "ticket_id": ticket_id,
                "success": False
            }
            
    def generate_fix(self, task_plan: Dict[str, Any], attempt: int = 1, 
                     previous_attempts: List[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Generate a code fix based on the task plan using GPT-4
        
        Args:
            task_plan: The task plan from PlannerAgent
            attempt: Current attempt number
            previous_attempts: List of previous attempts and their results
            
        Returns:
            Dictionary with patch information
        """
        if previous_attempts is None:
            previous_attempts = []
            
        # Read file contents for the files identified in the task plan
        file_contents = self._read_identified_files(task_plan.get("files", []))
        
        # Create prompt for GPT-4
        prompt = self._create_developer_prompt(task_plan, file_contents, previous_attempts)
        
        # Get code fix from GPT-4
        self.logger.info(f"Sending prompt to GPT-4 for code generation (attempt {attempt})")
        response = self.openai_client.generate_completion(prompt)
        
        if not response:
            raise Exception(f"Failed to generate code fix. OpenAI API call failed on attempt {attempt}.")
        
        # Parse the response to extract the patch content
        return self._extract_patch(response, task_plan)
            
    def _read_identified_files(self, files: List[Dict[str, Any]]) -> Dict[str, str]:
        """
        Read the contents of the files identified in the task plan
        
        Args:
            files: List of file dictionaries from task plan
            
        Returns:
            Dictionary mapping file paths to their contents
        """
        file_contents = {}
        
        for file_info in files:
            file_path = file_info.get("path", "")
            if not file_path:
                continue
                
            full_path = os.path.join(self.repo_path, file_path)
            
            try:
                with open(full_path, "r") as f:
                    content = f.read()
                    file_contents[file_path] = content
                    self.logger.info(f"Read file: {file_path}")
            except Exception as e:
                self.logger.warning(f"Could not read file {file_path}: {str(e)}")
                file_contents[file_path] = f"ERROR: Could not read file ({str(e)})"
                
        return file_contents
        
    def _create_developer_prompt(self, task_plan: Dict[str, Any], 
                              file_contents: Dict[str, str],
                              previous_attempts: List[Dict[str, Any]]) -> str:
        """
        Create a prompt for GPT-4 to generate a code fix
        
        Args:
            task_plan: The task plan from PlannerAgent
            file_contents: Dictionary mapping file paths to their contents
            previous_attempts: List of previous fix attempts and their results
            
        Returns:
            Prompt for GPT-4
        """
        # Basic prompt with task plan info
        prompt = f"""
        You are a senior software developer implementing a fix for a bug based on the following analysis:
        
        Bug Title: {task_plan.get('title', 'No title provided')}
        
        Bug Description: {task_plan.get('description', 'No description provided')}
        
        Root Cause: {task_plan.get('root_cause', 'Unknown')}
        
        Approach: {task_plan.get('approach', 'Not specified')}
        
        Implementation Details: {task_plan.get('implementation_details', 'Not specified')}
        
        """
        
        # Add file contents section
        prompt += "\nHere are the contents of the relevant files:\n\n"
        
        for file_path, content in file_contents.items():
            prompt += f"--- {file_path} ---\n"
            prompt += content
            prompt += "\n\n"
            
        # Add information from previous attempts if available
        if previous_attempts:
            prompt += "\nPrevious fix attempts:\n\n"
            
            for i, attempt in enumerate(previous_attempts):
                prompt += f"Attempt {i+1}:\n"
                if "patch_content" in attempt:
                    prompt += f"Patch:\n{attempt['patch_content']}\n"
                if "qa_results" in attempt:
                    passed = attempt["qa_results"].get("passed", False)
                    prompt += f"Test Result: {'PASSED' if passed else 'FAILED'}\n"
                    if not passed and "error_message" in attempt["qa_results"]:
                        prompt += f"Error: {attempt['qa_results']['error_message']}\n"
                prompt += "\n"
                
        # Instructions for generating the fix
        prompt += """
        Please implement a fix for the bug based on the analysis and file contents above.
        
        Provide your solution in the form of a unified diff/patch format. Include the entire file content
        for each modified file, not just the changes. Format your response like this:
        
        ```patch
        --- a/path/to/file1.py
        +++ b/path/to/file1.py
        @@ -line_start,line_count +line_start,line_count @@
         unchanged line
        -removed line
        +added line
         unchanged line
        
        --- a/path/to/file2.py
        +++ b/path/to/file2.py
        @@ -line_start,line_count +line_start,line_count @@
         unchanged line
        -removed line
        +added line
         unchanged line
        ```
        
        Please also include a brief commit message summarizing the changes at the start of your response.
        """
        
        return prompt
            
    def _extract_patch(self, response: str, task_plan: Dict[str, Any]) -> Dict[str, Any]:
        """
        Extract the patch content from GPT-4's response
        
        Args:
            response: GPT-4's response text
            task_plan: Original task plan
            
        Returns:
            Dictionary with patch_content, patched_files, and commit_message
        """
        # Extract commit message (first line or paragraph)
        lines = response.strip().split('\n')
        commit_message = lines[0].strip()
        
        # Find the patch content
        patch_start = response.find("```patch")
        if patch_start == -1:
            patch_start = response.find("```diff")
        
        if patch_start == -1:
            # No patch block found, look for --- patterns
            patch_lines = []
            in_patch = False
            
            for line in lines:
                if line.startswith("---") and "/path/to/" not in line:
                    in_patch = True
                
                if in_patch:
                    patch_lines.append(line)
                    
            patch_content = "\n".join(patch_lines)
            
        else:
            # Extract content between code blocks
            patch_start += 8  # Skip ```patch or ```diff
            patch_end = response.find("```", patch_start)
            
            if patch_end == -1:
                patch_content = response[patch_start:].strip()
            else:
                patch_content = response[patch_start:patch_end].strip()
                
        # Extract patched file paths
        patched_files = []
        for line in patch_content.split("\n"):
            if line.startswith("+++ b/"):
                file_path = line[6:].strip()
                patched_files.append(file_path)
                
        # If no patched files could be identified, try to get them from the task plan
        if not patched_files:
            for file_info in task_plan.get("files", []):
                file_path = file_info.get("path", "")
                if file_path:
                    patched_files.append(file_path)
                    
        # Build the result
        return {
            "patch_content": patch_content,
            "patched_files": patched_files,
            "commit_message": commit_message
        }
        
    def apply_patch(self, patch_data: Dict[str, Any]) -> bool:
        """
        Apply the patch to the local repository
        
        Args:
            patch_data: Dictionary with patch information
            
        Returns:
            Success status (True/False)
        """
        self.logger.info("Applying patch to local repository")
        
        # Write patch to temp file
        patch_file = f"temp_patch_{patch_data.get('ticket_id', 'unknown')}.patch"
        with open(patch_file, "w") as f:
            f.write(patch_data["patch_content"])
            
        # Apply patch using git
        try:
            import subprocess
            result = subprocess.run(
                ["git", "-C", self.repo_path, "apply", patch_file], 
                capture_output=True, 
                text=True
            )
            
            if result.returncode != 0:
                self.logger.error(f"Failed to apply patch: {result.stderr}")
                return False
                
            self.logger.info("Patch applied successfully")
            return True
            
        except Exception as e:
            self.logger.error(f"Error applying patch: {str(e)}")
            return False
        finally:
            # Clean up temp file
            if os.path.exists(patch_file):
                os.remove(patch_file)
